package 程序源码.解题;

import java.util.*;

public class 电脑解题 {

    private int 起始排列, 目标排列, 空白位置;

    public 电脑解题(int 起始排列, int 目标排列, int 空白位置) {
        this.起始排列 = 起始排列;
        this.目标排列 = 目标排列;
        this.空白位置 = 空白位置;//9表示空白
    }

    public LinkedList<Integer> 解题计算(功能接口 功能) {
        LinkedList<Integer> 解题步骤 = null;

        int 变量_当前排列 = 起始排列;
        int 变量_上步排列 = 起始排列;
        int 变量_空白位置 = 空白位置;
        int[] 记录_当前排列_空白位置;
        int[] 记录_下步排列_空白位置;
        while (变量_当前排列 != 目标排列) {
            记录_下步排列_空白位置 = 游戏规则.根据当前排列和空白的位置计算下一步所有的可能排列(变量_当前排列, 变量_空白位置);
            for (int ii = 0; ii < 记录_下步排列_空白位置.length; ii++) {
                if ((记录_下步排列_空白位置[ii] != 变量_上步排列) && (!功能.能否查到当前排列与上一步排列的对应关系(记录_下步排列_空白位置[ii]))) {
                    功能.推演_将当前数字排列写入队列末尾(记录_下步排列_空白位置[ii], 变量_当前排列, 游戏规则.数字N的位置计算规则[变量_空白位置][ii]);
                }
            }

            记录_当前排列_空白位置 = 功能.当前排列及空白按钮的位置();
            变量_上步排列 = 变量_当前排列;
            变量_当前排列 = 记录_当前排列_空白位置[0];
            变量_空白位置 = 记录_当前排列_空白位置[1];

            if (变量_当前排列 == 0) {
                break;
            }
            if (变量_当前排列 == 目标排列) {
                解题步骤 = 功能.生成解题步骤(目标排列, 起始排列);
                break;
            }
        }
        return 解题步骤;
    }
}
